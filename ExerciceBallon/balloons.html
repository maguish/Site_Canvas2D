<!doctype html>
<html lang="fr">

<head>
	<meta charset="utf-8">
	<title>Course de ballons</title>
	<style>
		body {
			background: #41567E;
			color: #FFFFFE;
		}

		canvas {
			margin: 15px auto 15px auto;
			display: block;
			width: 900 px;
			height: 600 px;
		}

		#page {
			margin-top: 15px;
		}
	</style>

</head>

<body>

	<div>
		<canvas id="canvas" width=900 height=600></canvas>

	</div>

	<script type="text/javascript" src="data.js"></script>

	<script>

		//	Fonction Constructeur

		function Bubble(x, y, r, color) {
			this.x = x;
			this.y = y;
			this.r = r; //radius
			this.color = color ? color : null;
		}

		// Méthode pour afficher les bulles

		Bubble.prototype.draw = function (ctx) {
			/* couleurs de remplissage */
			ctx.fillStyle = this.color;
			/* début de tracé */
			ctx.beginPath();
			ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI, true);
			/* remplissage */

			ctx.fill();
		}

		// Méthode pour afficher les bulles avec un dégradé linéaire

		Bubble.prototype.drawGradientLinear = function (ctx) {
			var linear = ctx.createLinearGradient(this.x-this.r,this.y-this.r,this.x,this.y+this.r);
		  linear.addColorStop(0.5, 'white');
		  linear.addColorStop(1, this.color);
			ctx.fillStyle = linear;
			ctx.beginPath();
			ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI, true);
			ctx.fill();
		}

		// Méthode pour afficher les bulles avec un dégradé radial
		
		Bubble.prototype.drawGradientRadial = function (ctx) {
			var radial = ctx.createRadialGradient(this.x,this.y,this.r,this.x,this.y,this.r/2);
		  radial.addColorStop(0.5, 'white');
		  radial.addColorStop(1, this.color);
			ctx.fillStyle = radial;
			ctx.beginPath();
			ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI, true);
			ctx.fill();
		}

		var canvas = document.getElementById('canvas');


		window.onload = function () {

			// Compter le nombre de valeurs différentes qui
			//se trouvent dans les données data pour l'attribut
			// attribute
			function countValues(data, attribute) {
				const map = new Map();
				let cpt = 0;
				for (let val of data) {
					for (let v in val) {
						if ((v == attribute) &&
							!Array.from(map.values()).includes(val[v])) {
							cpt += 1;
							map.set(cpt, val[v]);
						}
					}
				}
				console.log(map);

				// Retourner le nombre de valeurs uniques trouvées
				return map.size;
			}

			//palette de couleurs en utilisant le modèle RGB
			function createColors(n) {
				let tab = new Array();
				let i = 0;
				for (i = 0; i < n; i++) {
					g = (i / countValues(data, 'c')) * 255;
					r = 64;
					b = 128;
					tab[i] = "rgb(" + r + "," + g + "," + b + ")";
				}
				tab.forEach(c => { console.log("printColors " + c); });
				return tab;
			}

			// palette de couleurs en utilisant le modèle HSLA
			function generateHslaColors(n) {
				let colors = [];
				let huedelta = Math.trunc(360 / countValues(data, 'c'));
				for (let i = 0; i < n; i++) {
					const saturation = 50;
					const lightness = 60;
					const alpha = 0.5;
					let hue = i * countValues(data, 'c');
					colors.push(`hsla(${hue},${saturation}%,${lightness}%,${alpha})`);
				}
				return colors

			}

			// palette de couleurs en utilisant le gradientLinear
			function gobalGradientLinear(n) {
				// Create an array of colors using the gradient
				let color = [];
				var ctx = canvas.getContext('2d');
				for (let i = 0; i < n; i++) {
					const gradient = ctx.createLinearGradient(100, 0, canvas.width, 0);
					gradient.addColorStop(0, 'green');
					gradient.addColorStop(1, 'white');
					color.push(gradient);
				}
				return color
			}

			let colors = generateHslaColors(countValues(data, 'c') + 1);
			if (canvas.getContext) {
				var ctx = canvas.getContext('2d');
				let n1 = countValues(data, 'x');
				let n2 = countValues(data, 'y');
				let unitx = canvas.width / (n1 + 2)
				let unity = canvas.height / (n2 + 2);
				data.forEach(b => {
					let bubble = new Bubble(
						(b.x + 1) * unitx,
						(b.y + 1) * unity,
						b.r * 2,
						colors[b.c]);
					//bubble.draw(ctx)
					//bubble.drawGradientLinear(ctx)
					bubble.drawGradientRadial(ctx)

				});
			};


		}


	</script>
</body>

</html>
